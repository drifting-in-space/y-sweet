import { ParentChain } from './parent_chain'

test('iterating an empty chain terminates', () => {
  let chain = new ParentChain()
  let iter = chain[Symbol.iterator]()
  let result = iter.next()
  expect(result.done).toBe(true)
  expect(result.value).toBeUndefined()
})

test('iterating over individual values', () => {
  let chain = new ParentChain()
  chain.push('a')
  chain.push('b')
  chain.push('c')
  let result = new Set(chain[Symbol.iterator]())
  let expected = new Set(['a', 'b', 'c'])
  expect(result).toEqual(expected)
})

test('iterating over pairs', () => {
  let chain = new ParentChain()
  chain.push('a')
  chain.push('b')
  chain.push('c')
  chain.push('d')
  chain.push('e')
  let iter = chain.childParentPairs()[Symbol.iterator]()
  expect(iter.next()).toEqual({ done: false, value: ['d', 'e'] })
  expect(iter.next()).toEqual({ done: false, value: ['c', 'd'] })
  expect(iter.next()).toEqual({ done: false, value: ['b', 'c'] })
  expect(iter.next()).toEqual({ done: false, value: ['a', 'b'] })
  expect(iter.next()).toEqual({ done: true, value: undefined })
})

test('detecting a cycle', () => {
  let chain = new ParentChain()
  expect(chain.hasCycle()).toBe(false)
  chain.push('a')
  expect(chain.hasCycle()).toBe(false)
  chain.push('b')
  expect(chain.hasCycle()).toBe(false)
  chain.push('c')
  expect(chain.hasCycle()).toBe(false)
  chain.push('b')
  expect(chain.hasCycle()).toBe(true)
})

test('visiting a cycle from an arbitrary point', () => {
  let chain = new ParentChain()
  chain.push('a')
  chain.push('b')
  chain.push('c')
  chain.push('d')
  chain.push('e')
  chain.push('a')
  let iter = chain.childParentPairsFrom('c')[Symbol.iterator]()
  expect(iter.next()).toEqual({ done: false, value: ['b', 'c'] })
  expect(iter.next()).toEqual({ done: false, value: ['a', 'b'] })
  expect(iter.next()).toEqual({ done: false, value: ['e', 'a'] })
  expect(iter.next()).toEqual({ done: false, value: ['d', 'e'] })
  expect(iter.next()).toEqual({ done: true, value: undefined })
})

test('push after cycle is found throws', () => {
  let chain = new ParentChain()
  chain.push('a')
  chain.push('b')
  chain.push('c')
  chain.push('b')
  expect(() => chain.push('d')).toThrow('Cannot push')
})
